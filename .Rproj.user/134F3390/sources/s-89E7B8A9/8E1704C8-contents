# Class 9 - Exercise

# Clear memory
rm(list=ls())

# Call packages
#install.packages('WDI')
library(WDI)
library(tidyverse)
library(dplyr)
library(ggplot2)
# Packages to use
library(tidyverse)
# For scaling ggplots
require(scales)
# Estimate piecewise linear splines
#install.packages("lspline")
library(lspline)
# Estimate robust SE
#install.packages("estimatr")
library(estimatr)
# Compare models with robust SE
#install.packages("texreg")
library(texreg)
# For different themes
#install.packages(ggthemes)
library(ggthemes)

##########
# GET THE DATA

df <- WDI(indicator=c('SP.DYN.LE00.IN','SH.XPD.CHEX.PP.CD','SP.POP.TOTL'), 
                country="all", start=2017, end=2017)


##########
# CLEAN THE DATA


## Check the observations:
#   Lot of grouping observations
#     usually contains a number
d1 <- df %>% filter(grepl("[[:digit:]]", df$iso2c))
d1
# Filter these out
df <- df %>% filter( !grepl("[[:digit:]]", df$iso2c) )

# Some grouping observations are still there, check each of them
#   HK - Hong Kong, China
#   OE - OECD members
#   all with starting X, except XK which is Kosovo
#   all with starting Z, except ZA-South Africa, ZM-Zambia and ZW-Zimbabwe

# 1st drop specific values
drop_id <- c("EU","HK","OE")
# Check for filtering
df %>% filter( grepl( paste( drop_id , collapse="|"), df$iso2c ) ) 
# Save the opposite
df <- df %>% filter( !grepl( paste( drop_id , collapse="|"), df$iso2c ) ) 


# 2nd drop values with certain starting char
# Get the first letter from iso2c
fl_iso2c <- substr(df$iso2c, 1, 1)
retain_id <- c("XK","ZA","ZM","ZW")
# Check
d1 <- df %>% filter( grepl( "X", fl_iso2c ) | grepl( "Z", fl_iso2c ) & 
                       !grepl( paste( retain_id , collapse="|"), df$iso2c ) ) 
# Save observations which are the opposite (use of !)
df <- df %>% filter( !( grepl( "X", fl_iso2c ) | grepl( "Z", fl_iso2c ) & 
                          !grepl( paste( retain_id , collapse="|"), df$iso2c ) ) ) 

# Clear non-needed variables
rm( d1 , drop_id, fl_iso2c , retain_id )


### 
# Check for missing observations
m <- df %>% filter( !complete.cases( df ) )
# Drop if life-expectancy, gdp or total population missing -> if not complete case except iso2c
df <- df %>% filter( complete.cases( df ) | is.na( df$iso2c ) )



# CLEAN VARIABLES
#
# Recreate table:
#   Rename variables and scale them
#   Drop all the others !! in this case write into readme it is referring to year 2018!!
df <-df %>% transmute( country = country,
                       life_expectancy=SP.DYN.LE00.IN,
                       healthcare_expanditure=SH.XPD.CHEX.PP.CD,
                       healthcare_expanditure_tot=SH.XPD.CHEX.PP.CD*SP.POP.TOTL,
                       population=SP.POP.TOTL)

###
# Check for extreme values
# all HISTOGRAMS
df %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
  facet_wrap(~key, scales = "free") +
  geom_histogram()

# Check for summary as well
summary( df )




##########
# ANALYSE THE DATA

# Check basic scatter-plots!
#   Two competing models:
#     1) lifeexp = alpha + beta * health_expenditure
#     2) lifeexp = alpha + beta * health_expenditure_tot

# Where to use log-transformation? - level-level vs level-log vs log-level vs log-log
#
# 1) lifeexp - health_expenditure: level-level model without scaling
df %>% 
  ggplot(aes(x = healthcare_expanditure, y = life_expectancy)) +
  geom_point() +
  geom_smooth(method="loess")+
  labs(x = "Health Expenditure PC (2017 int. const. $, PPP )",y = "Life expectancy  (years)") 

# You can change the scale for Total Health expenditure for checking log-transformation
df %>% 
  ggplot(aes(x = healthcare_expanditure_tot, y = life_expectancy)) +
  geom_point() +
  geom_smooth(method="loess")+
  labs(x = "Total Health Expenditure (2017 int. const. $, PPP , ln scale )",y = "Life expectancy  (years)")

# You can change the scale for Total Health expenditure and life-expectancy for checking log-transformation
df %>% 
  ggplot(aes(x = healthcare_expanditure_tot, y = life_expectancy))  +
  geom_point() +
  geom_smooth(method="loess")+
  labs(x = "Total Health Expenditure  (2017 int. const. $, PPP , ln scale )",y = "Life expectancy  (years, ln scale)") +
  scale_x_continuous( trans = log_trans(),  breaks = c(1,2,5,10,20,50,100,200,500,1000,10000) )+
  scale_y_continuous( trans = log_trans() )


# Make some models:
#   w ln_health_expanditure_tot:
#     reg1: lifeexp = alpha + beta * ln_health_expanditure_tot
#     reg2: lifeexp = alpha + beta_1 * ln_health_expanditure_tot + beta_2 * ln_health_expanditure_tot^2
#     reg3: lifeexp = alpha + beta_1 * ln_health_expanditure_tot + beta_2 * ln_health_expanditure_tot^2 + beta_3 * ln_health_expanditure_tot^3
#   w ln_health_expanditure:
#     reg4: lifeexp = alpha + beta * ln_health_expanditure
#     reg5: lifeexp = alpha + beta_1 * ln_health_expanditure + beta_2 * ln_health_expanditure^2
#Extra: weighted-ols:
#     reg7: lifeexp = alpha + beta * ln_health_expanditure, weights: population

###
# Take Log of gdp/capita and log GDP total
df <- df %>% mutate( ln_health_expanditure = log( healthcare_expanditure ),
                     ln_health_expanditure_tot = log( healthcare_expanditure_tot ) )

# Two ways to handle polynomials: 
#
# 1) Add powers of the variable(s) to the dataframe:
df <- df %>% mutate( ln_health_expanditure_tot_sq = ln_health_expanditure_tot^2,
                     ln_health_expanditure_tot_cb = ln_health_expanditure_tot^3,
                     ln_health_expanditure_sq = ln_health_expanditure^2 )
#
# 2) Use 'poly(x,n)' function, which creates polynomials of x up to order n
#     use this approach for graphs! may use it for models: 
#                   positive - simpler, less new variables, 
#                   negative - uglier names, harder to compare
#     Note: poly() creates rotates your variables automatically to get mean independent variables
#       use raw = TRUE if you dont want to rotate your variables.

# Do the regressions
#
# Built in regression in R
reg_b <- lm(life_expectancy ~ ln_health_expanditure_tot, data = df)
reg_b
summary( reg_b )
# formula: y ~ x1 + x2 + ..., note: intercept is automatically added
# drawback: no robust SE, only homoskedastic SEs...
# So instead of lm we use lm_robust from package estimatr

# First model:
reg1 <- lm_robust( life_expectancy ~ ln_health_expanditure_tot , data = df , se_type = "HC2" )
reg1
# Summary statistics
summary( reg1 )
# Visual inspection:
df %>% 
  ggplot(aes( x = ln_health_expanditure_tot, y = life_expectancy) ) + 
  geom_point( color='blue') +
  geom_smooth( method = lm , color = 'red' )

# Second and third model with gdptot
reg2 <- lm_robust( life_expectancy ~ ln_health_expanditure_tot + ln_health_expanditure_tot_sq , data = df )
summary( reg2 )
ggplot( data = df, aes( x = ln_health_expanditure_tot, y = life_expectancy ) ) + 
  geom_point( color='blue') +
  geom_smooth( formula = y ~ poly(x,2) , method = lm , color = 'red' )

reg3 <- lm_robust( life_expectancy ~ ln_health_expanditure_tot + ln_health_expanditure_tot_sq + ln_health_expanditure_tot_cb , data = df )
ggplot( data = df, aes( x = ln_health_expanditure_tot, y = life_expectancy ) ) + 
  geom_point( color='blue') +
  geom_smooth( formula = y ~ poly(x,3) , method = lm , color = 'red' )


# Models with Health Expenditure per capita
reg4 <- lm_robust( life_expectancy ~ ln_health_expanditure , data = df )
summary( reg4 )
ggplot( data = df, aes( x = ln_health_expanditure, y = life_expectancy ) ) + 
  geom_point( color='blue') +
  geom_smooth( method = lm , color = 'red' )

reg5 <- lm_robust( life_expectancy ~ ln_health_expanditure + ln_health_expanditure_sq , data = df )
ggplot( data = df, aes( x = ln_health_expanditure, y = life_expectancy ) ) + 
  geom_point( color='blue') +
  geom_smooth( formula = y ~ poly(x,2) , method = lm , color = 'red' )


# Regression with piecewise linear spline:
# 1st define the cutoff for Health Expenditure per capita
cutoff <- 3000
# 2nd we use a log transformation -> cutoff needs to be transformed as well
cutoff_ln<- log( cutoff )
# Use simple regression with the lspline function
?lspline
reg6 <- lm_robust(life_expectancy ~ lspline( ln_health_expanditure , cutoff_ln ), data = df )
summary( reg6 )
ggplot( data = df, aes( x = ln_health_expanditure, y = life_expectancy ) ) + 
  geom_point( color='blue') +
  geom_smooth( formula = y ~ lspline(x,cutoff_ln) , method = lm , color = 'red' )

reg7 <- lm_robust(life_expectancy ~ ln_health_expanditure, data = df , weights = population)
summary( reg7 )

df %>% 
  ggplot( aes(x = ln_health_expanditure, y = life_expectancy)) +
  geom_point(data = df, aes(size=population),  color = 'blue', shape = 16, alpha = 0.6,  show.legend=F) +
  geom_smooth(aes(weight = population), method = "lm", color='red')+
  scale_size(range = c(1, 15)) +
  coord_cartesian(ylim = c(50, 85)) +
  labs(x = "ln(GDP per capita, thousand US dollars) ",y = "Life expectancy  (years)")+
  annotate("text", x = 4, y = 80, label = "USA", size=5)+
  annotate("text", x = 2.7, y = 79, label = "China", size=5)+
  annotate("text", x = 2,  y = 68, label = "India", size=5)


data_out <- "/Users/Terez/OneDrive - Central European University/Data_Analysis_02/"
htmlreg( list(reg1 , reg2 , reg3 , reg4 , reg5 , reg6 , reg7 ),
         type = 'html',
         custom.model.names = c("Health Expenditure total - linear","Health Expenditure total - quadratic","Health Expenditure total - cubic",
                                "Health Expenditure/capita - linear","Health Expenditure/capita - quadratic","Health Expenditure/capita - PLS",
                                "GDP/capita - weighted linear"),
         caption = "Modelling life expectancy and different health expenditure measures of countries",
         file = paste0( data_out ,'model_comparison.html'), include.ci = FALSE)


## Picking a models 
#   I have devided to go with the Health Expenditure/capita - linear model.
#   This model and the PCL have the same R^2 measure of 72% and both slopes
#   have a p-value of less than 0.1%. However, the linear model is easier to
#   interpret and is simpler to use in the future for predictions or other
#   analysis.

## Testing hypothesis
#

##
# 1) Coefficient is equal to 0:
# Implemented by default...
summary( reg4 )

# 2) Coefficient is equal to your favorite value
library(car)
# Let test: H0: ln_health_expanditure = 6, HA: ln_gdppc neq 5
linearHypothesis( reg4 , "ln_health_expanditure = 5")

# 3) Or two coefficients are the same in one model: 
#   in piecewise linear spline, the two coefficients are the same
summary( reg6 )
#   H0: lspline(ln_health_expanditure, cutoff_ln)1 - lspline(ln_health_expanditure, cutoff_ln)2 = 0
#   HA: lspline(ln_health_expanditure, cutoff_ln)1 - lspline(ln_health_expanditure, cutoff_ln)2 neq 0
linearHypothesis( reg6 , "lspline(ln_health_expanditure, cutoff_ln)1 = lspline(ln_health_expanditure, cutoff_ln)2")


#######
# Residual analysis.

# lm_robust output is an `object` or `list` with different elements
# Check the `Value` section
?lm_robust

# Get the predicted y values from the model
df$reg4_y_pred <- reg4$fitted.values
# Calculate the errors of the model
df$reg4_res <- df$life_expectancy - df$reg4_y_pred 

# Find countries with largest negative errors
df %>% top_n( -5 , reg4_res ) %>% 
  select( country , life_expectancy , reg4_y_pred , reg4_res )

# Find countries with largest positive errors
df %>% top_n( 5 , reg4_res ) %>% 
  select( country , life_expectancy , reg4_y_pred , reg4_res )


## Prediction uncertainty
#

# CI of predicted value/regression line is implemented in ggplot
df %>% 
  ggplot( aes( x = ln_health_expanditure, y = life_expectancy ) ) + 
  geom_point( color='blue') +
  geom_smooth( method = lm , color = 'red' , se = T )

##
# You can get them by predict function
#   interval can be any of c("none", "confidence", "prediction")
#   alpha = 0.05 (default) is the significance level
###
# CI of regression line
pred4_CI <- predict( reg4, newdata = df , interval ="confidence" , alpha = 0.05 )
pred4_CI

# If you want you can ask to calculate the SEs for each point:
# pred4_CI <- predict( reg4, newdata = df , se.fit=T,
#                  interval ="confidence" , alpha = 0.05 )

# Hand made CI for regression line
# 1) Add to datatset:
df <- df %>% mutate( CI_reg4_lower = pred4_CI$fit[,2],
                     CI_reg4_upper = pred4_CI$fit[,3] )
# 2) Plot
df %>% 
  ggplot(  ) + 
  geom_point(data = df, aes( x = ln_health_expanditure, y = life_expectancy ) , color='blue') +
  geom_line( data = df, aes( x = ln_health_expanditure, y = reg4_y_pred ) , color = 'red' , size = 1 ) +
  geom_line( data = df, aes( x = ln_health_expanditure, y = CI_reg4_lower ) , color = 'green' ,
             size = 1 , linetype = "dashed" ) +
  geom_line( data = df, aes( x = ln_health_expanditure, y = CI_reg4_upper ) , color = 'black' ,
             size = 1 , linetype = "dashed" ) +
  labs(x = "ln( Health Expenditure/capita, 2017 int. const. $, PPP)",y = "Life expectancy  (years)") 


##
# Now we change to get the prediction intervals!
#
pred4_PI <- predict( reg4, newdata = df , interval ="prediction" , alpha = 0.05 )

# Hand made Prediction Interval for regression line
# 1) Add to datatset (You can use the SE's as well if you wish...
#                        then alpha does not have any meaning)
df <- df %>% mutate( PI_reg4_lower = pred4_PI$fit[,2],
                     PI_reg4_upper = pred4_PI$fit[,3] )
# 2) Plot
df %>% 
  ggplot(  ) + 
  geom_point( data = df, aes( x = ln_health_expanditure, y = life_expectancy ) , color='blue') +
  geom_line( data = df, aes( x = ln_health_expanditure, y = reg4_y_pred ) , color = 'red' , size = 1 ) +
  geom_line( data = df, aes( x = ln_health_expanditure, y = PI_reg4_lower ) , color = 'green' ,
             size = 1 , linetype = "dotted" ) +
  geom_line( data = df, aes( x = ln_health_expanditure, y = PI_reg4_upper ) , color = 'black' ,
             size = 1 , linetype = "dotted" ) +
  labs(x = "ln( Health Expenditure/capita, 2017 int. const. $, PPP)",y = "Life expectancy  (years)") 


alpha <- as.numeric((reg4[["coefficients"]][["ln_health_expanditure"]]))
beta <- as.numeric((reg4[["coefficients"]][["(Intercept)"]]))

predict_life_exp <- function(country, health_expenditure) {
  ln_health_expenditure <- log(health_expenditure)
  life_expectency <- beta*ln_health_expenditure + alpha
  return(print(life_expectency))
}
